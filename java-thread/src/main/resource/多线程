多线程
	开发中主要的问题：
		1.死锁
		2.同步
		3.通信
		4.资源限制

	导致线程安全问题：
		1.死锁
		2.不同步

	线程状态
		初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。
		运行(RUNNABLE):处于可运行状态的线程正在JVM中执行，但它可能正在等待来自操作系统的其他资源，例如处理器。
		阻塞(BLOCKED)：线程阻塞于synchronized锁，等待获取synchronized锁的状态。
		等待(WAITING)：Object.wait()、join()、 LockSupport.park(),进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
		超时等待(TIME_WAITING)：Object.wait(long)、Thread.join()、LockSupport.parkNanos()、LockSupport.parkUntil，该状态不同于WAITING，
		它可以在指定的时间内自行返回。
		终止(TERMINATED)：表示该线程已经执行完毕。
	线程挂起跟恢复
		被废弃的方法
			thread.suspend() 该方法不会释放线程所占用的资源。如果使用该方法将某个线程挂起，则可能会使其他等待资源的线程死锁
			thread.resume() 方法本身并无问题，但是不能独立于suspend()方法存在
		可以使用的方法
			wait() 暂停执行、放弃已经获得的锁、进入等待状态
			notify() 随机唤醒一个在等待锁的线程
			notifyAll() 唤醒所有在等待锁的线程，自行抢占cpu资源
	守护线程
		一般线程为用户线程，当JVM实例中最后一个非守护线程结束时，也随JVM一起退出
	synchronized
		修饰普通方法：锁住对象的实例
    	修饰静态方法：锁住整个类
    	修饰代码块： 锁住一个对象 synchronized (lock) 即synchronized后面括号里的内容
    volatile
    	保证该变量的可见性，volatile关键字仅仅保证可见性，并不保证原子性（同步）
    	适合一写多读，不适合多写，多写也会导致线程不安全

    	A、B两个线程同时读取volatile关键字修饰的对象
    	A读取之后，修改了变量的值
    	修改后的值，对B线程来说，是可见

    	使用场景
    		1：作为线程开关
    		2：单例，修饰对象实例，禁止指令重排序

    锁
		自旋锁： 线程状态及上下文切换消耗系统资源，当访问共享资源的时间短，频繁上下文切换不值得。jvm实现，使线程在没获得锁的时候，不被挂起，转而执行空循环，循环几次之后，如果还没能获得锁，则被挂起

		阻塞锁：阻塞锁改变了线程的运行状态，让线程进入阻塞状态进行等待，当获得相应的信号（唤醒或者时间）时，才可以进入线程的准备就绪状态，转为就绪状态的所有线程，通过竞争，进入运行状态

		重入锁:支持线程再次进入的锁,就跟我们有房间钥匙，可以多次进入房间类似

		读写锁： 两把锁，读锁跟写锁，写写互斥、读写互斥、读读共享

		互斥锁： 上厕所，进门之后就把门关了，不让其他人进来

		悲观锁： 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁

		乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。

		公平锁：大家都老老实实排队，对大家而言都很公平

		非公平锁：一部分人排着队，但是新来的可能插队

		偏向锁：偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁

		独占锁：独占锁模式下，每次只能有一个线程能持有锁

		共享锁：允许多个线程同时获取锁，并发访问共享资源

	AbstractQueuedSynchronizer
		AbstractQueuedSynchronizer -- 为实现依赖于先进先出 (FIFO) 等待队列的阻塞锁和相关同步器（信号量、事件，等等）提供一个框架。
		此类的设计目标是成为依靠单个原子 int 值来表示状态的大多数同步器的一个有用基础。
		子类必须定义更改此状态的受保护方法，并定义哪种状态对于此对象意味着被获取或被释放。
		假定这些条件之后，此类中的其他方法就可以实现所有排队和阻塞机制。子类可以维护其他状态字段，但只是为了获得同步而只追踪使用 getState()、setState(int) 和 compareAndSetState(int, int) 方法来操作以原子方式更新的 int 值。
		应该将子类定义为非公共内部帮助器类，可用它们来实现其封闭类的同步属性。类 AbstractQueuedSynchronizer 没有实现任何同步接口。而是定义了诸如 acquireInterruptibly(int) 之类的一些方法，在适当的时候可以通过具体的锁和相关同步器来调用它们，以实现其公共方法。

		此类支持默认的独占 模式和共享 模式之一，或者二者都支持。处于独占模式下时，其他线程试图获取该锁将无法取得成功。在共享模式下，多个线程获取某个锁可能（但不是一定）会获得成功。此类并不“了解”这些不同，除了机械地意识到当在共享模式下成功获取某一锁时，下一个等待线程（如果存在）也必须确定自己是否可以成功获取该锁。处于不同模式下的等待线程可以共享相同的 FIFO 队列。通常，实现子类只支持其中一种模式，但两种模式都可以在（例如）ReadWriteLock 中发挥作用。只支持独占模式或者只支持共享模式的子类不必定义支持未使用模式的方法。

		此类通过支持独占模式的子类定义了一个嵌套的 AbstractQueuedSynchronizer.ConditionObject 类，可以将这个类用作 Condition 实现。isHeldExclusively() 方法将报告同步对于当前线程是否是独占的；使用当前 getState() 值调用 release(int) 方法则可以完全释放此对象；如果给定保存的状态值，那么 acquire(int) 方法可以将此对象最终恢复为它以前获取的状态。没有别的 AbstractQueuedSynchronizer 方法创建这样的条件，因此，如果无法满足此约束，则不要使用它。AbstractQueuedSynchronizer.ConditionObject 的行为当然取决于其同步器实现的语义。

		此类为内部队列提供了检查、检测和监视方法，还为 condition 对象提供了类似方法。可以根据需要使用用于其同步机制的 AbstractQueuedSynchronizer 将这些方法导出到类中。

		此类的序列化只存储维护状态的基础原子整数，因此已序列化的对象拥有空的线程队列。需要可序列化的典型子类将定义一个 readObject 方法，该方法在反序列化时将此对象恢复到某个已知初始状态。

		tryAcquire(int)
		tryRelease(int)
		tryAcquireShared(int)
		tryReleaseShared(int)
		isHeldExclusively()
			Acquire:
		     while (!tryAcquire(arg)) {
			        enqueue thread if it is not already queued;
			        possibly block current thread;
			     }

			Release:
				   if ((arg))
				        unblock the first queued thread;
		源码探秘之AQS如何用单一int值表示读写两种状态
			int 是32位，将其拆分成两个无符号short
			高位表示读锁          低位表示写锁
			0000000000000000   0000000000000000

			两种锁的最大次数均为65535也即是2的16次方减去1

			读锁： 每次都从当前的状态加上65536
			0000000000000000   0000000000000000
			‭0000000000000001   0000000000000000‬
			-----------------------------------
			0000000000000001   0000000000000000‬
			0000000000000001   0000000000000000‬
			-----------------------------------
			0000000000000010   0000000000000000‬

			获取读锁个数，将state整个无符号右移16位就可得出读锁的个数
							   0000000000000001 

			写锁：每次都直接加1
			0000000000000000   0000000000000000
			0000000000000000   0000000000000001
			-----------------------------------
			0000000000000000   0000000000000001

			获取写锁的个数
			0000000000000000   0000000000000001
			‭0000000000000000   1111111111111111‬	
			-----------------------------------	
			0000000000000000   0000000000000001
